function Economic_Dispatch(case, current_path_folder)
    base_MVA    = 100.0         # Base Power [MVA]

    #-----------------------------------------
    Clean_Terminal() # Clean the terminal
    #-----------------------------------------

    #-----------------------------------------
    # Generate a folder to export the results
    #-----------------------------------------
    name_path_results   = "Results"                                        # Name of the folder to save the results (it must be created in advance)
    path_folder_results = joinpath(current_path_folder, name_path_results) # Results directory
    cd(current_path_folder)                                                # Load the current folder

    #------------------------------------------
    # Call the function to read the input data
    #------------------------------------------
    input_data_path_folder = joinpath(current_path_folder, "Input_Data", case) # Folder name where the input data is located

    # Get the structs with data related to buses, generators and circuits
    DBUS, DGEN, DCIR, bus_mapping, reverse_bus_mapping = Read_Input_Data(input_data_path_folder) 

    # ---------------------------------------------------
    nBUS = length(DBUS.bus)      # Number of buses in the system
    nGEN = length(DGEN.id)       # Number of generators in the system
    nCIR = length(DCIR.from_bus) # Number of circuits in the system
    cd(current_path_folder)      # Load the current folder

    cost = DGEN.g_cost  # €/MWh
    Pₘₐₓ = DGEN.pg_max  # Rated power of each generator, MW
    Demand = sum(DBUS.p_d) # Sum of all demands

    # ########################################################################################
    #                                 STARTS OPTIMIZATION PROCESS 

    #-----------------------------------
    # Optimization model -> Setup
    #-----------------------------------
    model = JuMP.Model(HiGHS.Optimizer)
    JuMP.set_optimizer_attribute(model, "mip_rel_gap", 1e-8)    # Set optimality tolerance

    # Define Decision Variables for power generated by each unit:
    @variable(model, 0 <= P[n in 1:nGEN] <= Pₘₐₓ[n]) # MW

    # Define the constraints:
    @constraint(model, power_balance, sum(P) == Demand)  # Total power output equals demand

    # Define the objective function 
    Total_cost = cost' * P

    @objective(model, Min, Total_cost)

    print(model)
    println()

    ##############

    ## Solve the optimization problem
    optimize!(model)

    ##############

    ## Get the solution
    println()
    println("##########################################")
    println()
    println("SOLUTION:")
    println()

    println("Total cost: ", value(Total_cost), " €")
    println()

    println("Power output:")
    for i in 1:nGEN
        println("  - Generator $i: ", value(P[i]), " MW")
    end
    println()

    λₑₙₑᵣ = dual(power_balance) # Marginal price of energy, €/MWh
    println("Price of energy: ", λₑₙₑᵣ, " €/MWh")   

    #                               ENDS OPTIMIZATION PROCESS 
    # ########################################################################################
    println("--------------------------------------------------------------------------------------------------------------------------------------")
end