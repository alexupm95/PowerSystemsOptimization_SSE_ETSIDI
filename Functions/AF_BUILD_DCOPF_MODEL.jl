# Function to build the DC OPF model
function Make_DCOPF_Model!(model::Model, 
    B::SparseMatrixCSC,
    DBUS::DataFrame, 
    DGEN::DataFrame, 
    DCIR::DataFrame, 
    bus_gen_circ_dict::OrderedDict,
    base_MVA::Float64, 
    nBUS::Int64, 
    nGEN::Int64, 
    nCIR::Int64)

    """
    This function builds a general DC OPF Model with the objective function, variables and constraints
    """
    #---------------------------------------------
    # Get some variables associated with the buses
    #---------------------------------------------
    P_d  = deepcopy(DBUS.p_d) ./ base_MVA  # Active power demanded by the loads     [p.u.]

    #------------------------------------------
    # Check if there is at least one swing bus
    #------------------------------------------
    SW = findall(x -> x == 3, DBUS.type)
    if isempty(SW) 
        throw(ArgumentError("You must define one bus as the SLACK BUS (type 3).")) 
    elseif length(SW) > 1 
        throw(ArgumentError("This code still does not support more than one SLACK BUS (type 3).")) 
    end

    # Define the voltage at each bus equal to 1 p.u.
    V = OrderedDict(bus => 1.0 for bus in eachindex(DBUS.bus))

    # Get the power transfer limits of each branch
    lower_bounds_branch = -1.0 .* (DCIR.l_cap / base_MVA) # Lower Bounds
    upper_bounds_branch =  1.0 .* (DCIR.l_cap / base_MVA) # Upper Bounds

    # ========================================================================
    #              DEFINE THE VARIABLES OF THE MODEL
    # ========================================================================

    #-------------------------------------------------------------------------
    #                  Phase-angle of the voltage at the buses
    #-------------------------------------------------------------------------
    θ = OrderedDict{Int, JuMP.VariableRef}() # Dictionary to save the variables θ for each bus
    for bus in eachindex(DBUS.bus) # Loop in all buses
        θ[bus] = JuMP.@variable(model,
        lower_bound = -π, # Lower Bounds
        upper_bound = π,  # Upper Bounds
        base_name = "θ[$bus]"          # Decision variable -> Voltage angle at the buses [p.u.]
        )
    end

    #-------------------------------------------------------------------------
    #                  Active power generated by the generators
    #-------------------------------------------------------------------------
    P_g = OrderedDict{Int, JuMP.VariableRef}()
    for gen in 1:nGEN # Loop in all generators
        P_g[gen] = @variable(model,
            lower_bound = 0.0, # Lower Bounds
            upper_bound = DGEN.pg_max[gen] / base_MVA, # Upper Bounds
            base_name = "P_g[$gen]"
        )
    end
    
    # ========================================================================
    #            DEFINE THE OBJECTIVE FUNCTION OF THE MODEL
    # ========================================================================
    # Minimize total fuel cost
    model.ext[:objective] = OrderedDict{Symbol, Any}() # Dictionary to save the Objective Function
    total_cost = 0.0  # Initialize in zero

    for gen in 1:nGEN # Loop in all generators
        if DGEN.g_cost[gen] != 0.0
            total_cost += DGEN.g_cost[gen] * P_g[gen] * base_MVA
        end
    end

    model.ext[:objective] = @objective(model, Min, total_cost)
    
    # ========================================================================
    #            DEFINE THE CONSTRAINTS OF THE MODEL
    # ========================================================================

    # ******************************************
    # Equality Constraint -> angle of swing bus
    # ******************************************
    eq_const_angle_sw = OrderedDict{Int, JuMP.ConstraintRef}()

    if any(bus_gen_circ_dict[SW[1]][:gen_status] .== 1)                          # First check if the swing bus has at least one generator connected to it
        eq_const_angle_sw = JuMP.@constraint(model, θ[DBUS.bus[SW[1]]] == 0.0)   # Set the constraint -> Angle == 0
    else
        throw(ArgumentError("Swing bus $(SW[1]) must have at least one connected generator with status ON.")) # Throw an error if the swing bus has no generator connected to it
    end
   
    # ********************************************
    # Equality Constraints -> Active Power Balance
    # ********************************************

    p_flow_terms_dict = OrderedDict{Int, Vector{JuMP.GenericAffExpr{Float64, JuMP.VariableRef}}}() # Dictionary of active power inflow/outflow
    # Generating expressions for the power flow in and out of the bus
    for bus in DBUS.bus # Loop in all buses
        terms_p = JuMP.GenericAffExpr{Float64, JuMP.VariableRef}[]  # List of expressions

        indices_circ_connected = bus_gen_circ_dict[bus][:circ]       # Circuits connected to bus "bus"
        if isempty(indices_circ_connected)
            throw(ArgumentError("The bus $bus is islanded, i.e., there is no line or transformer connected to it."))
        end

        # Generate the power flow terms between each adjacent bus
        for (id_bus, f_bus) in enumerate(DCIR.from_bus)
            t_bus = DCIR.to_bus[id_bus]
            if f_bus == bus
                push!(terms_p, B[f_bus, t_bus] * (θ[f_bus] - θ[t_bus]))  # Power flows out of bus
            elseif t_bus == bus
                push!(terms_p, B[t_bus, f_bus] * (θ[t_bus] - θ[f_bus]))  # Power flows into bus
            end
        end
        p_flow_terms_dict[bus] = terms_p # Update the dictionary
    end

    eq_const_p_balance = OrderedDict{Int, JuMP.ConstraintRef}() # Dictionary used to save the equality constraints
    # Create the equality constraints
    for bus in 1:nBUS # Loop in all buses
        indices_bus_gen        = bus_gen_circ_dict[bus][:gen_ids] # Generators at bus "bus"
        indices_circ_connected = bus_gen_circ_dict[bus][:circ]    # Circuits connected to bus "bus
        terms_p                = p_flow_terms_dict[bus]           # Active power flow terms

        if isempty(indices_circ_connected) # Check if the bus has at least one branch connected to it
            throw(ArgumentError("The bus $bus is islanded, i.e., there is no line or transformer connected to it."))
        end

        # Get generator variables from the dictionary for those ON at this bus
        Pg_terms = [P_g[gen] for gen in indices_bus_gen if haskey(P_g, gen)]

        Pg_sum = isempty(Pg_terms) ? 0.0 : sum(Pg_terms) # Sum P_g terms; zero otherwise

        eq_const_p_balance[bus] = @constraint(model, sum(terms_p) == Pg_sum - P_d[bus])
    end

    # ****************************************************************
    # Inequality Constraints -> Power Transfer Limits in the Branches
    # ****************************************************************
    ineq_const_p_ik = OrderedDict{Int, JuMP.ConstraintRef}() # Dict to save inequality constraints of power transfer limits in the branches

    # Loop in all branches
    for branch = 1:nCIR        
        f_bus = DCIR.from_bus[branch]  # Bus from
        t_bus = DCIR.to_bus[branch]    # Bus to
        b = 1 / (DCIR.l_reac[branch])  # Branch series susceptance                          
        ineq_const_p_ik[branch] = JuMP.@constraint(model, get(lower_bounds_branch, branch, -Inf) <= b * (θ[f_bus] - θ[t_bus]) <= get(upper_bounds_branch, branch, Inf)) # Limit of the power flow from f_bus to t_bus
    end

    # =============================================================
    # Return model, variables and constraints to the main function
    # =============================================================
    return model, V, θ, P_g, eq_const_angle_sw, eq_const_p_balance, ineq_const_p_ik # Return the model to the main function
end